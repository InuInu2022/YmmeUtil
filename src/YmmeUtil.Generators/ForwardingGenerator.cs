using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace YmmeUtil.Generators;

[Generator]
public class ForwardingGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// クラス宣言を含むシンタックスノードを登録
		var classDeclarations = context
			.SyntaxProvider.CreateSyntaxProvider(
				predicate: static (s, _) => s is ClassDeclarationSyntax,
				transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node
			)
			.Where(static cds =>
				cds.Members.OfType<PropertyDeclarationSyntax>()
					.Any(static p =>
						p.AttributeLists.SelectMany(static a => a.Attributes)
							.Any(static a => a.Name.ToString().Contains("WrapForward"))
					)
			);

		// 出力の登録
		context.RegisterSourceOutput(
			classDeclarations,
			static (spc, classDeclaration) => GenerateForwardingCode(spc, classDeclaration)
		);
	}

	private static void GenerateForwardingCode(
		SourceProductionContext context,
		ClassDeclarationSyntax classSyntax
	)
	{
		var namespaceName = GetNamespace(classSyntax);
		var className = classSyntax.Identifier.Text;
		var accessModifier = GetAccessModifier(classSyntax);
		var properties = classSyntax
			.Members.OfType<PropertyDeclarationSyntax>()
			.Where(static p =>
				p.AttributeLists.SelectMany(static a => a.Attributes)
					.Any(static a => a.Name.ToString().Contains("WrapForward"))
			);

		if (!properties.Any())
			return;

		var sb = new StringBuilder();
		foreach (var property in properties)
		{
			var propertyName = property.Identifier.Text;
			var typeName = property.Type.ToString();

			var attribute = property
				.AttributeLists.SelectMany(static a => a.Attributes)
				.First(static a => a.Name.ToString().Contains("WrapForward"));

			var fieldName =
				attribute.ArgumentList?.Arguments.FirstOrDefault()?.ToString().Trim('"')
				?? "_internalObject";

			// プロパティのアクセサーを確認
			bool hasGetter =
				property.AccessorList?.Accessors.Any(static a =>
					string.Equals(a.Keyword.Text, "get", StringComparison.Ordinal)
				) ?? false;
			bool hasSetter =
				property.AccessorList?.Accessors.Any(static a =>
					string.Equals(a.Keyword.Text, "set", StringComparison.Ordinal)
				) ?? false;

			// アクセサーがない場合はデフォルトでgetter/setterの両方を持つと見なす
			if (property.AccessorList?.Accessors.Any() != true)
			{
				hasGetter = true;
				hasSetter = true;
			}

			// プロパティのアクセサーに基づいて適切なプロパティを生成
			var propertyText = $$""""
					public {{typeName}} {{propertyName}}
					{
						{{(hasGetter ? $"get => {fieldName}.{propertyName};" : "")}}
						{{(hasSetter ? $"set => {fieldName}.{propertyName} = value;" : "")}}
					}
				"""";

			sb.AppendLine(propertyText);
		}

		var source = $$"""
			// <auto-generated/>

			#nullable enable
			using System.Diagnostics.CodeAnalysis;

			namespace {{namespaceName}}
			{
				{{accessModifier}} partial class {{className}}
				{
					{{sb.ToString()}}
				}
			}
			""";

		context.AddSource($"{className}_Forwarding.g.cs", SourceText.From(source, Encoding.UTF8));
	}

	private static string GetAccessModifier(ClassDeclarationSyntax classSyntax)
	{
		if (
			classSyntax.Modifiers.Any(static m =>
				string.Equals(m.Text, "public", StringComparison.Ordinal)
			)
		)
			return "public";
		if (
			classSyntax.Modifiers.Any(static m =>
				string.Equals(m.Text, "internal", StringComparison.Ordinal)
			)
		)
			return "internal";
		if (
			classSyntax.Modifiers.Any(static m =>
				string.Equals(m.Text, "private", StringComparison.Ordinal)
			)
		)
			return "private";
		if (
			classSyntax.Modifiers.Any(static m =>
				string.Equals(m.Text, "protected", StringComparison.Ordinal)
			)
		)
			return "protected";

		return ""; // デフォルト（明示的なアクセス修飾子なし）
	}

	private static string GetNamespace(ClassDeclarationSyntax classSyntax)
	{
		var namespaceSyntax = classSyntax.Parent;
		while (namespaceSyntax != null && namespaceSyntax is not NamespaceDeclarationSyntax)
		{
			namespaceSyntax = namespaceSyntax.Parent;
		}

		return (namespaceSyntax as NamespaceDeclarationSyntax)?.Name.ToString()
			?? "GlobalNamespace";
	}
}
